{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Engineering Portfolio","text":"<p>Welcome to my portfolio! Over the past four years of studying Electrical Engineering and Electronics at LUT University, I have worked on numerous practical projects that demonstrate my skills and passion for the field. This site serves as a showcase of that work.</p> <p>Feel free to explore my projects via the \"Projects\" tab! The portfolio is a work in progress and will be updated as I finish new projects!</p> <p>Explore Projects</p>"},{"location":"#my-key-skills-interests","title":"My Key Skills &amp; Interests","text":"<p>Here is a quick summary of my skills and interests</p> <p>-System-level thinking</p> <ul> <li>I have typically a good grasp of the \"big picture\", and I understand how different pieces come together.</li> <li>I prioritize understanding how things work at a fundamental level.</li> </ul> <p>-Electronics design</p> <ul> <li>Small Signals, Mixed Signals, Power Regulation, PCB Design, Good EMI Practices, Controllers and Power Electronics.</li> <li>Wearable electronics: Dealing with battery operated high efficiency mixed signal measurement boards.</li> <li>Measurement boards and IMUs: I have work experience with custom measurement boards based on inertial measurement sensors (IMU) and magnetometers.</li> <li>I am especially interested in anything that can be held in hands and has a direct practical application!</li> </ul> <p>-Embedded systems</p> <ul> <li>Programming: C, C++</li> <li>Other languages I have used: Python, Java, HTML, CSS, JavaScript</li> <li>RTOS: I have experience with Zephyr RTOS and FreeRTOS </li> <li>Platforms: I have worked with nRF52 / nRF52840, Zybo Z7 (Zynq 7000), ESP32 and STM32 platforms</li> </ul> <p>-Control systems and Digital Signal Processing</p> <ul> <li>Motivation: I view mathematics and control theory as powerful tools in Embedded Systems. I have taken extra courses and built personal projects to master these tools for practical applications.</li> <li>DSP: I am interested in digital filters and algorithms. I have experience with complementary filtering and digital LPF / HPF filtering</li> <li> <p>IMU dataprocessing: I have work experience with human measurements based on IMU sensors.</p> <ul> <li>I have implemented a complementary filter for angle calculation.</li> <li>I have studied magnetic sensor calibration and various other calibration methods relating to 3D orientation and its calculation.</li> <li>Future goal: Implementing a Kalman filter for IMU sensor orientation processing on Embedded Hardware.</li> </ul> </li> </ul> <p>-3D printing and mechanical design</p> <ul> <li>3D Modelling: SolidWorks, OnShape.</li> <li>Calibration: flow, pressure advance, speed / quality, tolerances, diagnosing various issues. </li> <li>Process knowledge: Understanding how different materials affect the printing process and the end result (strength / quality).</li> <li>I have experience with Creality Ender 3 S1 pro, Creality K1C and Bambu Lab X1 Enterprise. <ul> <li>I currently own a temperamental K1C.</li> </ul> </li> </ul>"},{"location":"studies/","title":"Studies","text":""},{"location":"studies/#studies","title":"Studies","text":"<p>I am currently a first-year Master's student at university (4th year overall). I am looking for Master's thesis opportunities!</p> <p>Bachelors:  </p> <ul> <li>Major: Industrial Electronics / Teollisuuselektroniikka</li> <li>Thesis: \"System-level implementation of a wearable device suitable for motion analysis using the nRF52840 SoC\"</li> <li>GPA: 4.75 (180 credits)</li> </ul> <p>Masters:</p> <ul> <li>Major: Electronics</li> <li>Minor: Software Engineering / Ohjelmistotuotanto</li> </ul>"},{"location":"studies/#my-favourite-otherwise-relevant-courses","title":"My favourite / otherwise relevant courses:","text":"<ul> <li> <p>Applied Mathematics 1 (on-going)</p> <ul> <li>Key takeaways: Numerical mathematics / numerical methods support programming and digital dataprocessing nicely!</li> </ul> </li> <li> <p>C-ohjelmointi (C-programming)</p> <ul> <li>Key takeaways: Experience in C-language. Pointers, variable types, memory handling (malloc) etc.</li> </ul> </li> <li> <p>Olio-ohjelmointi (Object-oriented programming)</p> <ul> <li>Key takeaways: Object-oriented programming model and thinking, general software development, Java / Android studio</li> </ul> </li> <li> <p>Introduction to Web Development</p> <ul> <li>Key takeaways: CSS, JavaScript, HTML. Gained some experience with web development tools (AJAX, Leaflet, Bootstrap, Interaction with APIs, JSON manipulation)! Built a weather app website as my project work and achieved full points!</li> </ul> </li> <li> <p>Basics of Control Engineering</p> <ul> <li>Key takeaways:</li> <li>Gained a solid understanding of system analysis, stability analysis (Bode, Nyquist, Root Locus), and the fundamentals of control loops</li> </ul> </li> <li> <p>Digital Control 1 (on-going)</p> <ul> <li>Key takeaways: </li> <li>Deep dive into discrete control systems, discretization, state-space models.</li> <li>Very interesting course. I took this course purely for my own enjoyment as an extra.</li> </ul> </li> <li> <p>Electronics Project </p> <ul> <li>Key takeaways: Masters level project course. We did a project for a company. Learned a lot about working for a real customer. My role was software developer / Bluetooth developer.</li> </ul> </li> <li> <p>Electronics Laboratory 1 / 2 (laboratory / project courses), Analog Electronics 1 / 2 (laboratory / project courses) and Basics of Electronics 2 (project course)</p> <ul> <li>Key takeaways: I have strong background in practical laboratory work with electronics. I like projects where you get to solve problems and learn through practical experience.</li> </ul> </li> <li> <p>Introduction to Embedded Systems and Introduction Embedded System Programming (on-going)</p> <ul> <li> <p>Key takeaways:</p> </li> <li> <p>I was able to deepen my interest in embedded systems.</p> </li> <li>I purchased a Zybo Z7 board, which is used in the course. The programming course as a project work and the task is to implement converter code. I had a good grasp of the project from the beginning and was appointed as the project manager. I delegate tasks, design system architecture / structure, and implement the final code merge on my own Zybo.</li> </ul> </li> </ul>"},{"location":"projects/3D-printer-temp-control/","title":"3D Printer Enclosure Temp Control","text":""},{"location":"projects/3D-printer-temp-control/#the-3d-printer-enclosure-temp-control","title":"The 3D Printer Enclosure Temp Control","text":"<p>In this project I implemented a temperature controller for my old modded Ender 3 S1 Pro 3D printer.</p> <p>More coming soon...!</p>"},{"location":"projects/industrial-drone/","title":"The Industrial Drone","text":""},{"location":"projects/industrial-drone/#the-industrial-drone","title":"The Industrial Drone","text":"<p>I\u2019ve always wanted to build my own drone, so in 2023 I finally decided to make it happen. A drone is the perfect project for me because it combines all of my interests: power electronics, digital electroncis, RF communication, mechanics, embedded software. I chose to build a larger 'industrial-style' platform to serve as a platform for my own future custom attachments and experiments.</p> <p>While the project used mostly commercial components, the system integration was a challenge. Work began in late 2023 when a mountain of parts arrived without instructions. To turn them into a functional drone, I designed and 3D printed custom mounts for nearly every subsystem\u2014including cameras, batteries, antennas, and power distribution electronics.</p> <p>Key learnings:</p> <ul> <li>ArduPilot flight controller configuration.</li> <li>Drone systems: Basic components, battery technologies, wireless communication and protocols (MavLink, ELRS), and control electronics.</li> <li>Practical electronics skills.</li> <li>Deep dive on 3D printing (PLA, PETG) and 3D modelling (SolidWorks, OnShape).</li> </ul> <p>Future of the project: </p> <ul> <li>Design of my own power distribution board that measures current, filters the power and regualtes it for the electronics.</li> <li>Developing my own gimbal / camera orientation control system for the drone. </li> </ul>"},{"location":"projects/industrial-drone/#project-details","title":"Project Details","text":"<p>The project began with system simulation using eCalc to define the optimal powertrain. The motor, propeller, and ESC combination was selected to maximize payload capacity while ensuring high efficiency for extended flight times. Simulations indicated that an 11x4.5 propeller configuration offered the best performance. A 4S battery architecture was chosen to minimize overall system weight and costs. The final design has, accoring to the simulations, a theoretical thrust-to-weight ratio of 3:1 and a hover flight time of approximately 24 minutes, providing a lifting capacity of 3\u20134 kg with ample margin for future accessories.</p> <p> Simulation results for the components. </p> <p>Specs:</p> <ul> <li>Weight: ~2.2 - 2.5 kg (With 9200 mAh 4S LiPo battery)</li> <li>Motor Power: 4x 800W -&gt; ~3-4 kW peak power</li> <li>Estimated Max Thrust: ~ 4 kg</li> <li>Flight Time: 10 minutes rough flight, Smooth flight +20 minutes</li> <li>Max Current:  +120 A (measured, from 4S battery)</li> </ul> <p>Components:</p> <ul> <li>Motors: BrotherHobby Avenger V3 2812-900KV</li> <li>ESC: Hobbywing XRotor Pro 40A (60A Peak)</li> <li>Power Distribution Board: Mateksys XCLASS PDB FCHUB-12S</li> <li>Propellers: Biblade 11 x 4.5, carbon reinforced / 10x5 Triblade</li> <li>Flight Controller: Pixhawk 2.4.8</li> <li>Controller communication: Radiomaster RP3 ELRS transceiver with two antennas</li> <li>Frame: F450 Carbon Fiber with retracting arms</li> <li>VTX: Walksnail Avatar HD Pro kit V2</li> </ul> <p>The frame is a generic carbon fiber kit which arrived with no mounts for the battery, GoPro, or other peripherals. Starting with just the bare frame and countless bags of parts, I had to design custom mounts for practically every separate component to create a the complete drone system.</p> <p> The F450 carbon fiber frame. </p>"},{"location":"projects/industrial-drone/#battery-mount-and-power-distribution","title":"Battery Mount and Power Distribution","text":"<p>Since this drone is quite large and uses large batteries (~10 000 mAh / 4s) I used a separate RC car battery holder that was meant for heavy batteries. It was installed upside down on the drone with custom 3D printed mounts. The drone has a current sensor which I designed to lay in between the battery mount and the frame. This saved space and led to a convenient position for the battery XT-connectors.</p> <p> </p> <p> </p> <p>The current sensor feeds into the Power Distribution Unit (PDU), which splits power to the ESCs and regulates voltage for the flight controller and peripherals. I selected the Mateksys FCHUB-12S for its high current rating and control features, allowing me to toggle the video transmitter (VTX) via the remote controller to prevent overheating while on the ground.</p> <p> </p>"},{"location":"projects/industrial-drone/#wiring-and-cable-management","title":"Wiring and Cable Management","text":"<p>Reliability was a key priority for this build. I focused heavily on clean soldering (with flux) and cable management; almost every wire is neatly sheathed and routed to prevent snagging or vibration damage. The drone is designed to be modular and maintenance-friendly. High-quality XT and bullet connectors are used throughout, allowing components to be easily disassembled for upgrades or repairs.</p> <p> </p> <p> </p>"},{"location":"projects/industrial-drone/#accessory-mounts","title":"Accessory Mounts","text":"<p>To make the platform versatile, I designed a modular accessory mount system. It features a 45x45mm mounting holes, allowing virtually any custom device\u2014from cameras to sensors\u2014to be attached securely. In the future I am interested in desining a camera gimbal that fits on the accessory mount system.</p> <p>Currently, it can host a GoPro mount, a separate flashlight mount and an adjustable FPV camera mount. I also designed a specific holder for the FPV video transmitter to ensure it sits in the prop wash for cooling. The dual antennas are positioned in a V-formation at approximately 50 degrees to maximize video link range and signal diversity.</p> <p> </p> <p> </p> <p>The drone uses the ELRS protocol with the controller. I chose the Radiomaster RP3 ELRS transceiver with two antennas. A custom mount was also designed and 3D printed for this. The drone also has Telemetry link over MavLink and the drone or its status can be controlled from a laptop. The drone is also equipped with GPS and suits for completely automated missions.</p> <p> </p>"},{"location":"projects/industrial-drone/#covers-and-other-parts","title":"Covers and other parts","text":"<p>I also designed a cover for the flight controller and its cables and improve the aerodynamics of the drone. The 3D printer calibration was successful, and this is one of the best PETG prints I have ever made. Later, I redesigned the entire cover and added a lid with an OLED display showing the drone's status.</p> <p> </p> <p> </p> <p> </p>"},{"location":"projects/industrial-drone/#finished-build","title":"Finished Build","text":"<p>The drone is practically ready and airworthy. The drone flies nicely and works as expected. Overall the project was a success and a huge learning process for me. The project will likely continue according to the plans mentioned above.</p>"},{"location":"projects/monorotor/","title":"The Monorotor","text":""},{"location":"projects/monorotor/#the-monorotor-project","title":"The Monorotor Project","text":""},{"location":"projects/monorotor/#key-lessons-learned-from-the-project","title":"Key lessons learned from the project","text":"<ul> <li>Complementary filtering</li> <li>Inertial dataprocessing</li> <li>PID controller implementation</li> <li>PID tuning</li> <li>Mechanical design, 3D pringing, 3D modeling</li> </ul>"},{"location":"projects/monorotor/#project-description","title":"Project description","text":"<p> Hovering monorotor system.</p> <p>How does the device work and what does it do?</p> <p>The device has a hinge and a lever arm with a drone motor at the end. The lever arm is lifted by the drone motor and adjusted to the angle set by the user with a potentiometer. The aim of the project was to try to implement a PID controller in practice. </p> <p>I designed the 3D model, printed it, and built the test setup myself from scratch. The hinge parts and mounts for the motor, motor controller, and sensor are 3D printed from PETG plastic.</p> <p>The electronics consist of a generic BLDC motor, motor controller, MPU6050 inertial measurement unit, and microcontroller (Arduino Nano as a fast prototype). The hardware uses the IMU to measure the acceleration and angular velocity of the lever arm, which are used to calculate the angle of the lever arm with a complementary filter. This angle is adjusted with a PID controller. The angles and PID parameter values can be observed via a serial terminal on a computer.</p> <p>I implemented the complementary filter algorithm line by line using Matlab software because I wanted to understand how IMU data is calculated. The algorithm was easy to convert to C code. The use of the algorithm is practically mandatory because the acceleration sensor and gyroscope do not work well on their own. The algorithm combines the strengths of the sensors and cancels out their weaknesses to achieve a better angle estimate.</p> <p> The IMU sensor is attached with rubber mounting to isolate vibrations.</p> <p>I also calculated the PID controller manually from scratch and used the Tustin method for discretization. The PI controller was adjusted iteratively. The gain was increased until the system became unstable, and then the value was decreased slightly. The Ki gain was then increased until the system became unstable again, and it was lowered slightly. After this, the values were fine-tuned by analyzing the system's operation to achieve the best result.</p>"},{"location":"projects/monorotor/#results","title":"Results","text":"<p>The motor introduced massive vibrations that distorted the coplementary filter angle estimation. A digital low-pass filter was activated on the MPU6050 as well as a moving average was implemented on the microcontroller side. The MPU6050 was also fastened with a rubber mount to the shaft to reduce the vibrations and improve the complementary filter performance.</p> <p>There were a lot of mechanical issues. The bearing had unpredictable friction and considerable sideways wobble that introduced oscillations to the system. The motor also produces nonlinear force towards the gravity component depending on the shaft angle which made the tuning quite difficult with a basic iterative method. </p> <p>A marginally stable open loop step response was found manually. A throttle walue of 1420 (range: 1000-2000) led to a barely stable behaviour. System was extremely unstable and any further increse in the throttle would lead the system to flip completely upwards. The open loop system had a rise time of around 2-3 seconds with considerable overshoot. </p> <p>Open loop step-response.</p> <p>The system encountered a conflict between power and stability: lifting the arm required high gains, but these caused strong oscillations in the upper position. To correct this problem, I implemented multi-stage control logic. The controller uses aggressive gains Kp, Ki to raise the arm from rest, but automatically switches to conservative values near the target angle to maintain stable hovering without overshoot. The logic is visualized in the block diagram below.</p> <p> Control logic block diagram.</p> <p>The final performance of the controller was limited by mechanical issues and the iterative tuning method. Due to unpredictable friction and structural instability, the tuning method was changed to be overdamped response in order to prioritize stability over fast response. This prevented overshoot but resulted in a slow settling time of approximately 20 seconds and a steady-state error of 3\u20135 degrees. The tune could most likely be improved by iterating the gain values further. Future iterations would benefit from a physics-based mathematical model and improved mechanical design using bearings to reduce nonlinearities. Closed-loop system response is shown below.</p> <p> PID-tuned closed loop step-response.</p>"},{"location":"projects/monorotor/#future-of-the-project","title":"Future of the project","text":"<ul> <li>Improving PID controller tune based on a mathematical model of the system</li> <li>Improving system mechanics (adding bearings, redesigning the hinge etc.)</li> </ul>"},{"location":"projects/monorotor/#codes-and-other-materials","title":"Codes and other materials","text":"<p>The control software was written in C++. The code handles the IMU data acquisition via I2C, runs the complementary filter, and computes the PID output at a fixed sampling rate of 120Hz using Timer2 interrupts.</p> <p>Key details regarding code:</p> <ul> <li>Timer interrupts for fixed 120 Hz looping</li> <li>Complementary filter for angle estimation</li> <li>Variable PID parameters for countering unlinearity of the system dynamics</li> </ul>"},{"location":"projects/monorotor/#source-code","title":"Source Code:","text":"<pre><code>  #include &lt;Wire.h&gt;\n  #include &lt;Servo.h&gt;\n\n  // Pins\n  const int PIN_MOTOR = 11;\n  const int PIN_POT = A2;\n  const int MPU_ADDR = 0x68;\n\n  // Controller parameters:\n  const int controller_saturation_limit = 1700;\n  const int max_ref_angle = 90;\n\n  // PID settings\n  volatile float Kp = 1.5;   \n  volatile float Ki = 0.1;\n  volatile float Kd = 0.3;\n\n  // Complementary filter settings\n  const float alpha = 0.96; \n\n  // Variables:\n  volatile float currentAngle = 0;\n  volatile float gyroRate_prev = 0;\n  volatile float currentGyroRate = 0;\n  volatile float targetAngle = 0;\n  volatile float pi_err_prev = 0;\n  volatile float pi_yi_prev = 0;\n  volatile float err = 0;\n\n  const int moving_avg_size = 15;\n  int16_t rawAccY, rawAccZ, gyroX;\n  int16_t accYBuffer[moving_avg_size];\n  int16_t accZBuffer[moving_avg_size];\n  int bufferIndex = 0;\n\n  float debug_P = 0;\n  float debug_I = 0;\n  float debug_D = 0;\n\n  // Servo instance for the ESC. \n  // ESC is controlled with PWM.\n  Servo ESC;\n\n  // Bool = 8 bits = atomic operation with AVR processors!\n  // No mutex / semaphore needed when this is sampled!\n  bool read_data_flag = false;\n\n  #define sampling_rate 120\n\n  const float h = 1/(float)sampling_rate; // step size for integration\n\n\n  ISR(TIMER2_COMPA_vect){\n      read_data_flag = true;\n  }\n\n\n  void setup() {\n\n    // Stop interrupts during initialization!\n    // cli();\n\n    // Initialize serial communication to terminal  \n    Serial.begin(19200);\n    Serial.println(\"Begin system initialization...\\n\");\n    delay(1000);\n\n    // Init I2C communication with MPU6050\n    Wire.begin();\n    // MPU6050 Settings. Wake up from sleep and 8 MHz clock.\n    Wire.beginTransmission(MPU_ADDR);\n    Wire.write(0x6B); \n    Wire.write(0); \n    Wire.endTransmission(true);\n\n    // Set the MPU6050 digital low pass filter active for the ACC and Gyro.\n    Wire.beginTransmission(MPU_ADDR);\n    Wire.write(0x1A); // Set LPF register\n    Wire.write(0x05); // Write 42 Hz DLPF active\n    Wire.endTransmission(true); \n\n    // Zero the buffer depenfing on moving average size.\n    // For loop allows adjusting the buffer size with a variable.\n    for(int i=0; i&lt;moving_avg_size; i++){\n      accYBuffer[i] = 0; \n      accZBuffer[i] = 0;\n    }\n\n    // Initialize the angles.\n    // Sensor is read 50 times to obtain the initial angle of the system.\n    Serial.print(\"Calibrating...\");\n    long startSumY = 0, startSumZ = 0;\n    for(int i=0; i&lt;50; i++) {\n      readIMU();\n      startSumY += rawAccY;\n      startSumZ += rawAccZ;\n      delay(5);\n    }\n\n    // Set the initial angle according to the \"calibrated\" value.\n    // Only calculated based on acc values!\n    float startY = startSumY / 50.0;\n    float startZ = startSumZ / 50.0;\n    currentAngle = atan2(startY, startZ) * 180.0 / PI;\n\n    Serial.print(\"Initial Angle: \"); \n    Serial.println(currentAngle);\n\n    // Motor is controlled with ESC PWM library.\n    ESC.attach(PIN_MOTOR);\n    // 1000us = 0% throttle\n    // 2000us = 100% throttle\n    ESC.writeMicroseconds(1000);\n\n    Serial.println(\"System Initiated.\");\n    delay(1000);\n\n    // Initialize Timer and Interrupt\n    // We use TImer2 because servo library uses timer 1.\n    // Zero the \n    TCCR2A = 0;\n    TCCR2B = 0;\n    TCNT2  = 0;\n    // Set Timer2 to CTC, clear timer on count. This sets the repeating timer interval.\n    TCCR2B |= (1 &lt;&lt; WGM21); \n    // Set prescaler to 64\n    TCCR2B |= (1 &lt;&lt; CS22);  \n    // Activate timer2 interrupts.\n    TIMSK2 |= (1 &lt;&lt; OCIE2A);\n\n    OCR2A = 206; // 16MHZ / prescaler [64] / counter value 206 = 120 Hz \n\n    sei();\n\n  }\n\n  int incomingByte = 0; // for incoming serial data\n  uint8_t boost_P = 0;\n  uint8_t reduce_I = 0;\n\n  void loop() {\n\n    if (read_data_flag) {\n\n      // Reset the flag!\n      read_data_flag = false;\n\n      // reads the filtered IMU measurement values.\n      readIMU();\n\n      /* Read requested angle set with the potentiometer. */\n      int potValue = analogRead(PIN_POT);\n      /* Map the value in between 90 and -90 degrees. */\n\n      targetAngle = map(potValue, 0, 1023, -max_ref_angle, max_ref_angle); \n      currentAngle = complementaryFilter();\n\n      float pidOutput = 0;\n\n\n      // If the system is in rising stage, angle &lt; -20\n      if (currentAngle &lt; -20) {\n\n        // Reset reduce I state\n        reduce_I = 0;       \n        // Increase power\n        pidOutput = PIDController(2.0*Kp, 3.0*Ki, 1.25*Kd, targetAngle, currentAngle, h);\n\n      } else { \n\n        // Check if we are close to level or the Integrator is floating / too high\n        if (currentAngle &gt; -5 &amp;&amp; pi_yi_prev &gt; 100.0) {\n            // Reduce the I linerly\n            pi_yi_prev = pi_yi_prev - 0.5; \n        }\n\n        // Calculate with normal PID parameters and compensated intergrator.\n        pidOutput = PIDController(Kp, Ki, Kd, targetAngle, currentAngle, h);\n      }\n\n      // pidOutput = PIDController(Kp, Ki, Kd, targetAngle, currentAngle, h);\n\n      int baseThrottle = 1100;\n      int motorPWM = baseThrottle + (int)pidOutput;\n\n      int finalPWM = constrain(motorPWM, 1000, controller_saturation_limit);\n      ESC.writeMicroseconds(finalPWM);\n\n      static int printCounter = 0;\n      if (++printCounter &gt;= 25) { \n        Serial.print(\"Tgt ang:\"); Serial.print(targetAngle, 1);\n        Serial.print(\"Cur ang;\"); Serial.print(currentAngle, 1);\n        Serial.print(\" | P:\"); Serial.print(debug_P, 1);\n        Serial.print(\" | I:\"); Serial.print(debug_I, 1);\n        Serial.print(\" | D: \"); Serial.print(debug_D, 1);\n        Serial.print(\" | Cur throt: \"); Serial.print(finalPWM, 1);\n        Serial.print(\"\\r\\n\");\n        printCounter = 0;\n      }\n    }\n  }\n\n  void readIMU() {\n\n    // Initiate read from MPU6050 Acc data register 0x3B\n    Wire.beginTransmission(MPU_ADDR);\n    Wire.write(0x3B);\n    Wire.endTransmission(false);\n\n    // Start actual read from the data register.\n    // Read 6 bits at a time from the 0x3B register.\n    // Continue from next register.\n    Wire.requestFrom(MPU_ADDR, 6, true);\n\n    int8_t acc_x_msb = Wire.read();\n    int8_t acc_x_lsb = Wire.read();\n    int8_t acc_y_msb = Wire.read();\n    int8_t acc_y_lsb = Wire.read();\n    int8_t acc_z_msb = Wire.read();\n    int8_t acc_z_lsb = Wire.read(); \n\n    // Shift and cast MSB and LSB into one 16bit signed value.\n    int16_t acc_x = (int16_t)(acc_x_msb &lt;&lt; 8 | acc_x_lsb);\n    int16_t acc_y = (int16_t)(acc_y_msb &lt;&lt; 8 | acc_y_lsb);\n    int16_t acc_z = (int16_t)(acc_z_msb &lt;&lt; 8 | acc_z_lsb);\n\n    // Initiate read from MPU6050 Gyro data register 0x43\n    Wire.beginTransmission(MPU_ADDR);\n    Wire.write(0x43);\n    Wire.endTransmission(false);\n    Wire.requestFrom(MPU_ADDR, 6, true);\n\n    // Start actual read from the data register.\n    int8_t gyro_x_msb = Wire.read();\n    int8_t gyro_x_lsb = Wire.read();\n\n    // Shift and cast MSB and LSB into one 16bit signed value.\n    gyroX = (int16_t)(gyro_x_msb &lt;&lt; 8 | gyro_x_lsb);\n\n    // Moving Average / Ring buffer Filtering:\n    accYBuffer[bufferIndex] = acc_y;\n    accZBuffer[bufferIndex] = acc_z;\n\n    bufferIndex++;\n    // If the buffer index is reached, jump to beginning.\n    if (bufferIndex &gt;= moving_avg_size){\n      bufferIndex = 0;\n    }\n\n    long sumY = 0, sumZ = 0;\n    for(int i=0; i&lt;moving_avg_size; i++){ \n      sumY += accYBuffer[i];\n      sumZ += accZBuffer[i];\n    }\n    rawAccY = sumY / moving_avg_size;\n    rawAccZ = sumZ / moving_avg_size;\n  }\n\n  float complementaryFilter() {\n\n    // Calculate angle based on Acc:\n    float accAngleDeg = atan2(rawAccY, rawAccZ)*(180.0/PI);\n\n    // Convert rad/s to deg/s:\n    float gyroRateDeg = (float)gyroX/(131.0); \n\n    // Integrate gyro reading to change of angle:\n    float deltaAngleGyro = (h/2.0)*(gyroRateDeg + gyroRate_prev);\n\n    // Store the revious gyro result for next round integration;\n    gyroRate_prev = gyroRateDeg;\n    currentGyroRate = gyroRateDeg;\n    // Estimate new angle based on Gyro (previous + change of anlge):\n    float angleEstimateGyro = currentAngle + deltaAngleGyro;\n\n    // Fuse the two results:\n    float fusedAngle = alpha*angleEstimateGyro + (1.0-alpha)*accAngleDeg;\n\n\n    return fusedAngle;\n  }\n\n  float PIDController(float Kp, float Ki, float Kd, float ref, float y, float h) {\n\n      float yp, yi, yd, out;\n\n      // Integrator saturation value.  \n      const float max_i_term = 350.0; \n\n      err = ref - y;\n\n      yp = Kp * err;\n\n      // Integrate gyro angles with trapezoidal method.\n      yi = Ki * (h / 2.0) * (err + pi_err_prev) + pi_yi_prev;\n\n      if(yi &gt; max_i_term){\n        yi = max_i_term;\n      } else if(yi &lt; -max_i_term){\n        yi = -max_i_term;\n      }\n\n      // yd = Kd*((err-pi_err_prev)/h);\n      // calculate derivative from gyroscope, not the error and potentiometer....\n      yd = -Kd * currentGyroRate;\n\n      out = yp + yi + yd;\n\n      debug_P = yp;\n      debug_I = yi;\n      debug_D = yd;\n\n      pi_yi_prev = yi;\n      pi_err_prev = err;\n\n      return out;\n  }\n</code></pre>"},{"location":"projects/rcCar/","title":"The RC Car!","text":"<p>This project was completed as a group assignment during my first year at LUT University (2022-2023). I was our team leader. As my first deep dive into electronics and embedded programming, it holds a special place in my portfolio. This was a bold project for freshers and took endless hours at the JHC prototyping lab to finalize, but we managed to pull it off.</p> <p>The Project: We developed a custom wireless control system for an RC car. While the mechanical chassis was pre-made, we designed and built the controller and all vehicle electronics from scratch. We faced challenges with connection reliability (10\u201320m range) and occasional throttle sticking, but the result was a functional (and a bit temperamental) RC-car. </p> <p>My Role: Beyond leadership, my primary responsibility was designing the controller hardware and writing the firmware for both the transmitter and the receiver. The system utilized Arduino Nano microcontrollers, nRF24L01 transceivers, and an L298N motor driver. I later improved the software to include features like toggling between high and low beam headlights and better visualization for throttle values etc.</p> <p>Key Lessons: This project was a crash course in hardware debugging. I vividly remember the radio modules refusing to work until we realized the critical importance of decoupling capacitors on the power lines. I also learned a practical lesson in power integrity and ground loops: despite using separate batteries, poor grounding layout caused the headlights to dim whenever the motor drew high current.</p> <p>The hard work paid off, and our team was honored with the 'Best Project of the Year' award of the course.</p> <p></p> <p></p> <p></p> <p>The codes were modified from https://dronebotworkshop.com/nrf24l01-wireless-joystick/ example project \"Wireless Joystick for Arduino Robot Car with nRF24L01+\". </p>"},{"location":"projects/rcCar/#source-codes","title":"Source codes","text":""},{"location":"projects/rcCar/#controller","title":"Controller","text":"<pre><code>    /*\n    nRF24L01+ Joystick Transmitter\n    nrf24l01-joy-xmit-car.ino\n    nRF24L01+ Transmitter with Joystick for Robot Car\n    Use with Joystick Receiver for Robot Car\n    DroneBot Workshop 2018\n    https://dronebotworkshop.com\n    */\n\n    //Libraries\n    #include &lt;RHReliableDatagram.h&gt;\n    #include &lt;RH_NRF24.h&gt;\n    #include &lt;SPI.h&gt;\n    #include &lt;Wire.h&gt;\n    #include &lt;MicroLCD.h&gt;\n\n    //Display constants\n    LCD_SH1106 lcd;  \n\n\n    //Joystick Connections\n    #define joyVert    A0 \n    #define joyHorz    A1\n    // Define Joystick Values - Start at 512 (middle position)\n    int joyposVert = 512;\n    int joyposHorz = 512;\n    #define CLIENT_ADDRESS 1   \n    #define SERVER_ADDRESS 2\n    RH_NRF24 RadioDriver;\n    RHReliableDatagram RadioManager(RadioDriver, CLIENT_ADDRESS);\n    uint8_t motorcontrol[5]; \n    // motorcontrol[0] = throttle direction\n    // motorcontrol[1] = steering direction\n    // motorcontrol[2] = throttle speed\n    // motorcontrol[3] = steering angle\n    // motorcontrol[4] = Headlights on/off\n    // Define the Message Buffer\n\n    //Other constants\n    #define sw1 4\n    #define sw2 6\n    uint8_t buf[RH_NRF24_MAX_MESSAGE_LEN];\n\n    void setup()\n    { \n    // Setup Serial Monitor\n    Serial.begin(9600);\n    lcd.begin();\n    lcd.clear();\n    pinMode(sw1, INPUT_PULLUP);\n    // Initialize RadioManager with defaults - 2.402 GHz (channel 2), 2Mbps, 0dBm\n    if (!RadioManager.init())\n        Serial.println(\"init failed\");\n    // Set initial motor direction as forward\n    motorcontrol[2] = 0;\n    // headlights initially off\n    motorcontrol[4] = -1;\n    }\n\n    void loop()\n    {\n    // Print to Serial Monitor\n    Serial.println(\"Reading motorcontrol values \");\n\n    motorcontrol[4] = digitalRead(sw1);\n    joyposVert = analogRead(joyVert); \n    joyposHorz = analogRead(joyHorz);\n    Serial.println(digitalRead(sw1));\n    draw(joyposVert);\n    draw2(joyposHorz);\n    // throttle /////////////////////////////////////////////////\n    if (joyposVert &lt; 460)\n    {\n        motorcontrol[0] = 1;\n        motorcontrol[2] = map(joyposVert, 460, 0, 0, 255);\n    }\n    else if (joyposVert &gt; 564)\n    {\n        motorcontrol[0] = 0;\n        motorcontrol[2] = map(joyposVert, 564, 1023, 0, 255);\n    }\n    else\n    {\n        motorcontrol[0] = 0;\n        motorcontrol[2] = 0;\n    }\n\n    // Steering /////////////////////////////////////////////////\n\n    if (joyposHorz &lt; 460)\n    {\n        motorcontrol[1] = 1;\n        motorcontrol[3] = map(joyposHorz, 460, 0, 0, 255);\n    }\n    else if (joyposHorz &gt; 564)\n    {\n        motorcontrol[1] = 0;\n        motorcontrol[3] = map(joyposHorz, 564, 1023, 0, 255);\n    }\n    else\n    {\n        motorcontrol[1] = 0;\n        motorcontrol[3] = 0;\n    }\n\n    if(digitalRead(sw1)==LOW){\n        motorcontrol[4] = motorcontrol[4]*-1;\n    }\n\n    //Display the Motor Control values in the serial monitor.\n    Serial.print(\"Motor A: \");\n    Serial.print(motorcontrol[0]);\n    Serial.print(\" - Motor B: \");\n    Serial.print(motorcontrol[1]);\n    Serial.print(\" - Direction: \");\n    Serial.println(motorcontrol[2]);\n    Serial.print(\"Headlights: \");\n    Serial.println(motorcontrol[4]);\n\n    //Send a message containing Motor Control data to manager_server\n    if (RadioManager.sendtoWait(motorcontrol, sizeof(motorcontrol), SERVER_ADDRESS))\n    {\n        // Now wait for a reply from the server\n        uint8_t len = sizeof(buf);\n        uint8_t from;\n        if (RadioManager.recvfromAckTimeout(buf, &amp;len, 2000, &amp;from))\n        {\n        Serial.print(\"got reply from : 0x\");\n        Serial.print(from, HEX);\n        Serial.print(\": \");\n        Serial.println((char*)buf);\n        }\n        else\n        {\n        Serial.println(\"No reply, is nrf24_reliable_datagram_server running?\");\n        }\n    }\n    else\n        Serial.println(\"sendtoWait failed\");\n    delay(5);\n    lcd.clear();\n\n\n    }\n\n    void draw(int value){\n    lcd.setCursor(0,0);\n    lcd.setFontSize(FONT_SIZE_MEDIUM);\n    lcd.print(value);\n    lcd.print(\"throttle\");\n    lcd.println();\n    }\n    void draw2(int value){\n    lcd.setCursor(0,5);\n    lcd.setFontSize(FONT_SIZE_MEDIUM);\n    lcd.print(value);\n    lcd.print(\"steering\");\n    lcd.println();\n\n    }\n\n    void error(){\n    lcd.setCursor(0,47);\n    lcd.setFontSize(1);\n    lcd.println(\"ERROR!\");\n    delay(2000);\n    lcd.clear();\n    }\n</code></pre>"},{"location":"projects/rcCar/#car","title":"Car","text":"<pre><code>    /*\n    nRF24L01+ Joystick Transmitter\n    nrf24l01-joy-xmit-car.ino\n    nRF24L01+ Transmitter with Joystick for Robot Car\n    Use with Joystick Receiver for Robot Car\n    DroneBot Workshop 2018\n    https://dronebotworkshop.com\n    */\n\n    // Include RadioHead ReliableDatagram &amp; NRF24 Libraries\n    #include &lt;RHReliableDatagram.h&gt;\n    #include &lt;RH_NRF24.h&gt;\n    #include &lt;Wire.h&gt;\n    #include &lt;Adafruit_GFX.h&gt;\n    #include &lt;Adafruit_SH110X.h&gt;\n    // Include dependant SPI Library \n    #include &lt;SPI.h&gt;\n\n    // Define Joystick Connections\n    #define joyVert    A0 \n    #define joyHorz    A1\n\n    // Define Joystick Values - Start at 512 (middle position)\n    int joyposVert = 512;\n    int joyposHorz = 512;\n\n    // Define addresses for radio channels\n    #define CLIENT_ADDRESS 1   \n    #define SERVER_ADDRESS 2\n\n    // Create an instance of the radio driver\n    RH_NRF24 RadioDriver;\n\n    // Sets the radio driver to NRF24 and the client address to 1\n    RHReliableDatagram RadioManager(RadioDriver, CLIENT_ADDRESS);\n\n    // Declare unsigned 8-bit motorcontrol array\n    // 2 Bytes for motor speeds plus 1 byte for direction control\n    uint8_t motorcontrol[3]; \n\n    // Define the Message Buffer\n    uint8_t buf[RH_NRF24_MAX_MESSAGE_LEN];\n\n    //CONSTANTS\n    #define i2c_Address 0x3c //initialize with the I2C addr 0x3C Typically eBay OLED's\n    #define SCREEN_WIDTH 128 // OLED display width, in pixels\n    #define SCREEN_HEIGHT 64 // OLED display height, in pixels\n    #define OLED_RESET -1   //   QT-PY / XIAO\n    Adafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);\n    display.begin(i2c_Address, true); // Address 0x3C default\n\n    void setup()\n    {\n    // Setup Serial Monitor\n    Serial.begin(9600);\n    display.display();\n    delay(200);\n    display.clearDisplay();\n\n    // Initialize RadioManager with defaults - 2.402 GHz (channel 2), 2Mbps, 0dBm\n    if (!RadioManager.init())\n        Serial.println(\"init failed\");\n\n    // Set initial motor direction as forward\n    motorcontrol[2] = 0;\n    }\n\n    void loop()\n    {\n    // Print to Serial Monitor\n    Serial.println(\"Reading motorcontrol values \");\n\n    // Read the Joystick X and Y positions\n    joyposVert = analogRead(joyVert); \n    joyposHorz = analogRead(joyHorz);\n\n    // Determine if this is a forward or backward motion\n    // Do this by reading the Verticle Value\n    // Apply results to MotorSpeed and to Direction\n\n    if (joyposVert &lt; 460)\n    {\n        // This is Backward\n        // Set Motors backward\n        motorcontrol[2] = 1;\n\n        //Determine Motor Speeds\n        // As we are going backwards we need to reverse readings\n        motorcontrol[0] = map(joyposVert, 460, 0, 0, 255);\n        motorcontrol[1] = map(joyposVert, 460, 0, 0, 255);\n\n    }\n    else if (joyposVert &gt; 564)\n    {\n        // This is Forward\n        // Set Motors forward\n        motorcontrol[2] = 0;\n\n        //Determine Motor Speeds\n        motorcontrol[0] = map(joyposVert, 564, 1023, 0, 255);\n        motorcontrol[1] = map(joyposVert, 564, 1023, 0, 255); \n\n    }\n    else\n    {\n        // This is Stopped\n        motorcontrol[0] = 0;\n        motorcontrol[1] = 0;\n        motorcontrol[2] = 0; \n\n    }\n\n    // Now do the steering\n    // The Horizontal position will \"weigh\" the motor speed\n    // Values for each motor\n\n    if (joyposHorz &lt; 460)\n    {\n        // Move Left\n        // As we are going left we need to reverse readings\n        // Map the number to a value of 255 maximum\n        joyposHorz = map(joyposHorz, 460, 0, 0, 255);\n\n        motorcontrol[0] = motorcontrol[0] - joyposHorz;\n        motorcontrol[1] = motorcontrol[1] + joyposHorz;\n\n        // Don't exceed range of 0-255 for motor speeds\n        if (motorcontrol[0] &lt; 0)motorcontrol[0] = 0;\n        if (motorcontrol[1] &gt; 255)motorcontrol[1] = 255;\n\n    }\n    else if (joyposHorz &gt; 564)\n    {\n        // Move Right\n        // Map the number to a value of 255 maximum\n        joyposHorz = map(joyposHorz, 564, 1023, 0, 255);\n\n        motorcontrol[0] = motorcontrol[0] + joyposHorz;\n        motorcontrol[1] = motorcontrol[1] - joyposHorz;\n\n        // Don't exceed range of 0-255 for motor speeds\n        if (motorcontrol[0] &gt; 255)motorcontrol[0] = 255;\n        if (motorcontrol[1] &lt; 0)motorcontrol[1] = 0;      \n\n    }\n\n    // Adjust to prevent \"buzzing\" at very low speed\n    if (motorcontrol[0] &lt; 8)motorcontrol[0] = 0;\n    if (motorcontrol[1] &lt; 8)motorcontrol[1] = 0;\n\n    //Display the Motor Control values in the serial monitor.\n    Serial.print(\"Motor A: \");\n    Serial.print(motorcontrol[0]);\n    Serial.print(\" - Motor B: \");\n    Serial.print(motorcontrol[1]);\n    Serial.print(\" - Direction: \");\n    Serial.println(motorcontrol[2]);\n\n    //Send a message containing Motor Control data to manager_server\n    if (RadioManager.sendtoWait(motorcontrol, sizeof(motorcontrol), SERVER_ADDRESS))\n    {\n        // Now wait for a reply from the server\n        uint8_t len = sizeof(buf);\n        uint8_t from;\n        if (RadioManager.recvfromAckTimeout(buf, &amp;len, 2000, &amp;from))\n        {\n        Serial.print(\"got reply from : 0x\");\n        Serial.print(from, HEX);\n        Serial.print(\": \");\n        Serial.println((char*)buf);\n        }\n        else\n        {\n        Serial.println(\"No reply, is nrf24_reliable_datagram_server running?\");\n        }\n    }\n    else\n        Serial.println(\"sendtoWait failed\");\n\n    delay(100);  // Wait a bit before next transmission\n    }\n</code></pre>"},{"location":"projects/testbench/","title":"The Drone Motor Test bench","text":""},{"location":"projects/testbench/#the-drone-motor-testbench-work-in-progress","title":"The Drone Motor Testbench (Work in Progress)","text":"<p>This is a personal project that is a work in progress. The idea for this project arose from the need to optimize motor-propeller combinations for the industrial drone project.</p>"},{"location":"projects/testbench/#general-description-of-the-device","title":"General description of the device","text":"<p>The aim of the project is to design and implement a test bench suitable for drone motors, capable of measuring the current, voltage and power of the drone motor, the rotational speed of the motor or blades, and the thrust generated by the motor. The idea is that different combinations of motors, propellers, and motor controllers can be tested to achieve the best efficiency.</p> <p>The device measures the motor's current and voltage which can be used to calculate the power taken from the battery. The device measures the thrust generated by the motor with a load cell that is mechanically coupled to the motor. The propeller rotational speed is also measured with an optical sensor.</p>"},{"location":"projects/testbench/#planned-features","title":"Planned features","text":"<ul> <li>Compatibility for various types of motors and motor controllers.</li> <li>Web UI for graphing measurement results in real time</li> <li>Battery operable from typical drone batteries (input voltage range up to 30 V) </li> <li>Automated test sequences</li> </ul>"},{"location":"projects/testbench/#target-specifications","title":"Target specifications","text":"<p>Current measurements:</p> <ul> <li>Max Current: 60 A</li> <li>Accuracy:   100 mA</li> <li>Resolution: 10 mA.</li> <li>Bandwidth: 10 kHz.</li> </ul> <p>Voltage measurements:</p> <ul> <li>Max input Voltage: 30 V</li> <li>Accuracy: 100 mV</li> <li>Resolution: 10 mV.</li> <li>Bandwidth: 10 kHz.</li> </ul> <p>Thrust measurements:</p> <ul> <li>Range: 0-5 kg</li> <li>Accuracy: 20g</li> <li>Resolution: 10g</li> </ul> <p>Propeller measurements:</p> <ul> <li>Rotational speed: 20 000 rpm</li> <li>Accuracy: 100 rpm</li> </ul>"},{"location":"projects/testbench/#current-progress-initial-designs-very-much-subject-to-change","title":"Current Progress / Initial Designs (Very much Subject to Change)","text":"<p>The initial plan for the system has been created and is shown in the block diagram below. The exact components may still change. In particular, the ADCs may still be changed. The goal is to implement the different parts of the system step by step and eventually integrate everything onto a single circuit board.</p> <p>The project is intended to be as modular as possible so that it can be developed in parts. For example, a cost effective and readily available generic load cell + HX711 ADC combination was been chosen for thrust measurement. This will be replaced later with a higher-quality solution later on. </p> <p> System block diagram (WIP).</p>"},{"location":"projects/testbench/#component-selection","title":"Component Selection","text":"<p>The ESP32 was chosen as the microprocessor because it has Wifi capability and can stream the measurement results via a web server UI. </p>"},{"location":"projects/testbench/#current-measurement","title":"Current Measurement","text":"<p>The Allegro Microsystems ACS37032-065B3 Hall-effect current sensor was selected for the project because it met all the requirements and was reasonably priced. In addition, the package is easy to solder by hand and the sensor appeared to be simple to use.</p> <p>Datasheet:</p> <p>The sensor is capable of measuring current up to 65 amps with a bandwidth of 5 MHz, which is sufficient for one drone motor and meets the project requirements. The sensor produces a voltage proportional to the current passing through with a sensitivity of 20.3 mV/A. At full 65 A current, the sensor produces an output voltage of approximately 1.32 V. Although the internal resistance of the measurement circuit is low (0.6 m\u03a9), the power loss generated at peak currents is significant (2.5 W) and requires sufficient cooling.</p> <p>The ACS772LCB-100B-SMT-T might have been a better choice for the current sensor. Its internal resistance is only 100 micro-ohms, so it would have been better able to withstand continuous loading. In addition, its current measurement range is up to 100 A, so it could also have been used with larger motors.</p> <p>Datasheet:</p>"},{"location":"projects/testbench/#adcs-and-buffering","title":"ADCs and buffering","text":"<p>The 16-bit Microchip MCP33131 ADCs were chosen for their high sampling rate (up to 1 Msps). Since the MCP33131 uses a Successive Approximation Register (SAR) architecture, it draws a dynamic current during the acquisition phase. To prevent voltage droop and ensure measurement accuracy, an op-amp voltage buffer was implemented in the signal path.</p> <p>The MCP6022 dual op-amp was selected as the buffer due to its high Gain Bandwidth Product (10 MHz) and cost-effectiveness. Its Rail-to-Rail Input/Output (RRIO) capability is essential for this single-supply, low-voltage system. The signal path design is iterative; future versions will include tuned anti-aliasing filters to further improve signal integrity.</p> <p> Sensors and ADCs (WIP). </p>"},{"location":"projects/testbench/#power-regulation","title":"Power regulation","text":"<p>The power architecture is divided into two stages to ensure signal integrity and efficiency.</p> <p>Analog and Digital Logic: The MCP33131 ADC requires a clean 1.8 V analog supply, while its digital interface supports voltages from 2.5 V to 5 V. A 3.3 V rail was selected for the digital interface to match the ESP32\u2019s SPI logic levels directly. To minimize noise coupling and ensure measurement accuracy, all sensitive analog components (ADC, Op-Amps, and sensors) are powered via dedicated Low Dropout Regulators (LDOs).</p> <p>Primary Power Stage: The main system power\u2014supplying the ESP32, LDO inputs, and the cooling fan\u2014is handled by a DC-DC buck converter stage. This stage is implemented using the TPS62933 synchronous buck converter. The IC supports a wide input voltage range of 3.8 V to 30 V, which provides significant flexibility: the test bench electronics can be powered directly by almost any standard drone battery pack (ranging from 1S to 6S) independent of the motor power supply.</p> <p> Power regulators (WIP).</p>"},{"location":"projects/testbench/#pcb-design","title":"PCB design","text":"<p>The PCB design is currently in the preliminary layout phase. The physical dimensions of the board are largely dictated by the ESP32 Development Kit footprint, which was chosen to accelerate the prototyping process.</p> <p>Handling currents up to 65 A requires special attention in the layout. The design features wide, exposed copper planes (soldermask removed) on both top and bottom layers. This allows for manual solder tinning to increase the effective conductor thickness, thereby reducing resistance and improving thermal management.</p> <p>Things that will be considered in the build:</p> <ul> <li>Stackup: Planned 4-layer configuration (SIG/PWR \u2013 GND \u2013 GND \u2013 SIG) to ensure solid return paths and noise suppression.</li> <li>Signal Integrity: Series termination on high-speed SPI buses; impedance-controlled routing for critical signals.</li> <li>Mixed-Signal Layout: Strict physical separation between digital logic and sensitive analog domains; minimized trace lengths for analog signals.</li> <li>High Current Path: Reinforced copper pours exposed for solder tinning to handle up to 65 A in the measurement section.</li> <li>Thermal Management: Component placement optimized for airflow and heat dissipation, particularly for the current measurement and regulators.</li> <li>Modularity: Design allows for future upgrades or swapping of specific sub-circuits.</li> <li>ESD / polarity protection of inputs</li> <li>Testpoints and proper silkscreens</li> </ul> <p> Draft of the PCB design. </p>"}]}